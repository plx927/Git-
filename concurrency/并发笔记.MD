1.为啥newCachedThreadPool？
从名字的含义来看，即该线程池对线程具有的缓存能力。
```
    public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>());
    }
```
这体现在keepAliveTime这个参数上，线程池根据这个参数会对处于闲置的线程缓存60S;当一个线程闲置的时间达到60s，就会被线程池所回收，这个缓存的时间可以根据实际的情况显示使用ThreadPoolExecutor来创建进行设置。


2.Executors里的那个创建缓存线程池的方法，为啥要用SynchronousQueue？
CachedThreadPool除了对线程池具备缓存的能力外，它其实还具备对线程进行很好的伸缩与扩展能力(调节能力):
即在线程闲置的情况下可以被全部回收，而线程数量不够的情况下就快速的创建线程立即执行任务。

要回答`对于为什么使用SynchronousQueue`这个问题，得从ThreadPoolExecutor的execute方法所执行的流程展开来讲：
1. 首先判断线程池中当前线程的数量是否小于corePoolSize,如果小于则直接创建新线程来进行任务的执行。
2. 如果线程池中的线程数量已经大于等于corePoolSize,那么则尝试将任务往队列中添加，如果添加成功，
   在将将任务存放到BlockingQueue中。
3. 如果添加失败，则判断当前线程池中的线程数是否已经达到maxPoolSize，
   如果未达到，则将创建新的线程(这些线程在处理完成后被所回收的时间取决于设置的keepAliveTime);
   如果已经达到，则抛出RejectExecutionExcetpion，我们可以定义拒绝策略来进行处理。  
    
从cachedThreadPoolExecutor的创建所给定的参数可以看到，其corePoolSize为0，maxPoolSize为Integer.MAX_VALUE。
从这两个参数我们可以看出，线程池在闲置的情况下，其数量为0，而线程**理论上**可到达的最大数量为可Integer.MAX_VALUE。
SynchronousQueue这个队列的特点是只能有一个任务存在于队列中，结合线程池的执行流程来看：
当执行第一个任务的时候，其实队列就已经满了，后续加入的任务，
会立即创建新的线程进行任务的执行；这样就能很好的验证该线程池具备很好的扩展能力(让任务快速执行)。
而如果其他BlockingQueue的实现，由于其可以存放多个任务，那么后续的任务会被先添加到缓冲队列中，从而无法让任务得到立即执行的效果。

综上所述：其使用SynchronousQueue是一种不得已而为之的方法，只有这样才能让后续的任务可以得到立即执行


现在有两个场景:
- 第一个场景是平稳吞吐量的大量小任务，你可以理解为每秒创建10000个任务，每个任务执行0.1秒，例如订单处理。
- 第二个场景是吞吐量大幅度变化的小任务，有时候并发10，有时候突然来几百万个任务，例如秒杀业务。
让你对这两个场景应用线程池，你应该用那种池哪种队列

第一个场景:因为平稳的吞吐量，因此可以设置大**小固定线程线程池(FixedThreadPool)**,根据实际服务器的cpu数量设置相应的线程数，
使用LinkedBlockingQueue作为任务的缓冲队列，并且保持其默认的capacity=Integer.MAX_VALUE。_

第二个场景:由于该场景下吞吐量变化浮动变化很大，因此需要**利用CachedThreadPool**对于线程数量可调节的特性，
但是CachedThreadPool底层默认使用的SynchronousQueue,使用该队列当任务非常多就会导致大量的线程创建，这很有可能造成OOM。
因此我的想法是首先保持固定大小的线程，然后使用LinkedBlockingQueue，但是需要在创建的时候修改其默认的capacity,其原因在于
如果使用默认的capacity，会导致后续增加的任务全部都入到队列里面，从而导致任务处理过慢。
因此需要设置队列合适的capacity，并且同时设置线程池的maxPoolSize,当任务无法再添加到队列时此时可能是负载过高的情况了，因此
我们不得不启动新的线程来进行处理。












